// CYBERPUNK PORTFOLIO SYSTEM - VERSION 3.0
// Sistema ultra-cyberpunk con efectos gaming y IA

// System variables
let terminalOutput = [];
let terminalIndex = 0;
let isTerminalOpen = false;
let systemStats = {
    cpu: 45,
    memory: 62,
    network: 88,
    security: 95
};

// Neural stats for AI widget
let neuralStats = {
    neural: 72,
    processing: 89,
    memory: 45
};

// Sistema de sonidos cyberpunk
const cyberpunkSounds = {
    click: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+KhYqFbF1fdJivrJBhNjVgodDbq2EcBj',
    open: 'data:audio/wav;base64,UklGRpQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YXQDAAA/f3//f3//f3//f3//f3//f3//f3//f3//f3//f3//f3//f3//f3//f3//f3//f3',
    close: 'data:audio/wav;base64,UklGRrQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZADAADy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8v'
};

function playSound(soundType) {
    if (cyberpunkSounds[soundType]) {
        const audio = new Audio(cyberpunkSounds[soundType]);
        audio.volume = 0.3;
        audio.play().catch(e => console.log('Audio play failed:', e));
    }
}

// Matrix console functionality
function toggleMatrixConsole() {
    const console = document.getElementById('matrixConsole');
    const isOpen = console.classList.contains('open');
    
    if (isOpen) {
        console.classList.remove('open');
        playSound('close');
    } else {
        console.classList.add('open');
        playSound('open');
        if (!consoleInitialized) {
            initializeMatrixConsole();
        }
    }
}

let consoleInitialized = false;
let matrixLines = [];

function initializeMatrixConsole() {
    const output = document.getElementById('matrixOutput');
    consoleInitialized = true;
    
    const initMessages = [
        '> MATRIX_CONSOLE_v2.1_INITIALIZED',
        '> Loading neural pathways...',
        '> Connecting to mainframe...',
        '> ACCESS_GRANTED',
        '> Ready for commands...'
    ];
    
    initMessages.forEach((msg, index) => {
        setTimeout(() => {
            addMatrixLine(msg, index === 0 ? 'system' : 'success');
        }, index * 500);
    });
    
    // Auto-update console
    setInterval(updateMatrixConsole, 3000);
}

function addMatrixLine(text, className = '') {
    const output = document.getElementById('matrixOutput');
    const line = document.createElement('div');
    line.className = `console-line ${className}`;
    line.textContent = text;
    output.appendChild(line);
    
    // Keep only last 15 lines
    const lines = output.children;
    if (lines.length > 15) {
        output.removeChild(lines[0]);
    }
    
    output.scrollTop = output.scrollHeight;
}

function updateMatrixConsole() {
    const messages = [
        '> Scanning quantum signatures...',
        '> Neural network sync: 98.7%',
        '> Firewall status: ACTIVE',
        '> Data stream: 2.4 GB/s',
        '> Encryption level: MAXIMUM',
        '> Anomaly detected in sector 7',
        '> Running diagnostic protocols...',
        '> Memory optimization complete',
        '> Ghost protocol activated'
    ];
    
    const randomMsg = messages[Math.floor(Math.random() * messages.length)];
    addMatrixLine(randomMsg);
}

// Widget functionality
function updateTimeWidget() {
    const now = new Date();
    const timeElement = document.getElementById('digitalClock');
    const dateElement = document.getElementById('dateDisplay');
    
    if (timeElement) {
        const time = now.toLocaleTimeString('en-US', { 
            hour12: false,
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
        timeElement.textContent = time;
    }
    
    if (dateElement) {
        const date = now.toLocaleDateString('en-US', {
            weekday: 'short',
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        });
        dateElement.textContent = date;
    }
}

function updateAIStats() {
    // Simulate fluctuating AI metrics
    neuralStats.neural += (Math.random() - 0.5) * 5;
    neuralStats.processing += (Math.random() - 0.5) * 3;
    neuralStats.memory += (Math.random() - 0.5) * 4;
    
    // Keep values in bounds
    Object.keys(neuralStats).forEach(key => {
        neuralStats[key] = Math.max(0, Math.min(100, neuralStats[key]));
    });
    
    // Update UI
    const neuralFill = document.querySelector('.neural-fill');
    const processFill = document.querySelector('.process-fill');
    const memoryFill = document.querySelector('.memory-fill');
    
    if (neuralFill) neuralFill.style.width = neuralStats.neural + '%';
    if (processFill) processFill.style.width = neuralStats.processing + '%';
    if (memoryFill) memoryFill.style.width = neuralStats.memory + '%';
    
    // Update values
    const neuralValue = document.getElementById('neuralValue');
    const processValue = document.getElementById('processValue');
    const memoryValue = document.getElementById('memoryValue');
    
    if (neuralValue) neuralValue.textContent = Math.round(neuralStats.neural) + '%';
    if (processValue) processValue.textContent = Math.round(neuralStats.processing) + '%';
    if (memoryValue) memoryValue.textContent = Math.round(neuralStats.memory) + '%';
}

// Quantum lab functionality
function updateQuantumLab() {
    const experiments = document.querySelectorAll('.quantum-bar');
    experiments.forEach((bar, index) => {
        const progress = Math.random() * 100;
        bar.style.width = progress + '%';
    });
    
    const labOutput = document.getElementById('labOutput');
    if (labOutput) {
        const labMessages = [
            'Quantum entanglement: STABLE',
            'Particle acceleration: 99.8%',
            'Field harmonics: OPTIMAL',
            'Dimensional barrier: INTACT',
            'Energy matrix: CHARGING...'
        ];
        
        const randomMsg = labMessages[Math.floor(Math.random() * labMessages.length)];
        const line = document.createElement('div');
        line.className = 'lab-line success';
        line.textContent = '> ' + randomMsg;
        labOutput.appendChild(line);
        
        // Keep only last 10 lines
        if (labOutput.children.length > 10) {
            labOutput.removeChild(labOutput.children[0]);
        }
    }
}

// Holographic gallery functionality
let currentHoloView = 'personal';

function switchHoloView(view) {
    currentHoloView = view;
    const buttons = document.querySelectorAll('.holo-btn');
    buttons.forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    
    updateHoloGallery();
    playSound('click');
}

function updateHoloGallery() {
    const grid = document.getElementById('holoGrid');
    if (!grid) return;
    
    const galleries = {
        personal: [
            { name: 'Profile_Holo.png', desc: 'Neural scan profile' },
            { name: 'Team_Alpha.jpg', desc: 'Squad formation' },
            { name: 'Mission_12.holo', desc: 'Operation records' },
            { name: 'Achievement.gif', desc: 'Victory moments' }
        ],
        work: [
            { name: 'Project_Neo.3d', desc: 'AI development' },
            { name: 'Code_Matrix.holo', desc: 'Neural networks' },
            { name: 'Data_Visual.png', desc: 'Analytics display' },
            { name: 'Team_Build.jpg', desc: 'Development team' }
        ],
        projects: [
            { name: 'Cyber_UI.design', desc: 'Interface concepts' },
            { name: 'Quantum_Lab.3d', desc: 'Laboratory model' },
            { name: 'Neural_Net.holo', desc: 'AI architecture' },
            { name: 'Future_Tech.png', desc: 'Technology preview' }
        ]
    };
    
    const currentGallery = galleries[currentHoloView] || galleries.personal;
    
    grid.innerHTML = currentGallery.map(photo => `
        <div class="holo-frame">
            <div class="holo-image">
                <div class="photo-placeholder">ðŸ“¸</div>
                <div class="holo-effect"></div>
            </div>
            <div class="photo-info">
                <strong>${photo.name}</strong><br>
                ${photo.desc}
            </div>
        </div>
    `).join('');
}

// Carrusel hologrÃ¡fico functionality
let currentSlide = 0;
const totalSlides = 4;

function initHoloCarousel() {
    const dots = document.querySelectorAll('.carousel-dot');
    const track = document.getElementById('carouselTrack');
    
    if (!track) return;
    
    // Event listeners para los dots
    dots.forEach((dot, index) => {
        dot.addEventListener('click', () => {
            goToSlide(index);
            playSound('click');
        });
    });
    
    // Auto-rotate carousel
    setInterval(() => {
        currentSlide = (currentSlide + 1) % totalSlides;
        goToSlide(currentSlide);
    }, 3000);
}

function goToSlide(slideIndex) {
    const track = document.getElementById('carouselTrack');
    const dots = document.querySelectorAll('.carousel-dot');
    
    if (!track) return;
    
    currentSlide = slideIndex;
    
    // Move track
    const translateX = -slideIndex * 100;
    track.style.transform = `translateX(${translateX}%)`;
    
    // Update dots
    dots.forEach(dot => dot.classList.remove('active'));
    if (dots[slideIndex]) {
        dots[slideIndex].classList.add('active');
    }
}

// Spartan arsenal functionality
function selectWeapon(weaponName) {
    const slots = document.querySelectorAll('.weapon-slot');
    slots.forEach(slot => slot.classList.remove('selected'));
    event.currentTarget.classList.add('selected');
    
    playSound('click');
    
    // Update status
    const statusElement = document.querySelector('.spartan-status .status-bar');
    if (statusElement) {
        statusElement.innerHTML = `
            <span>WEAPON: ${weaponName.toUpperCase()}</span>
            <span>STATUS: ARMED</span>
        `;
    }
}

// Settings functionality
function toggleSetting(settingName) {
    const toggle = event.currentTarget;
    const isActive = toggle.classList.contains('active');
    
    if (isActive) {
        toggle.classList.remove('active');
    } else {
        toggle.classList.add('active');
    }
    
    playSound('click');
    
    // Apply setting effects
    switch(settingName) {
        case 'particles':
            // Toggle particles
            break;
        case 'sound':
            // Toggle sound
            break;
        case 'animations':
            // Toggle animations
            document.body.classList.toggle('no-animations', !toggle.classList.contains('active'));
            break;
        case 'grid':
            // Toggle grid overlay
            const grid = document.querySelector('.cyberpunk-grid');
            if (grid) {
                grid.style.display = toggle.classList.contains('active') ? 'block' : 'none';
            }
            break;
    }
}

// Original modal functions
function showModal(modalId) {
    playSound('open');
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.classList.add('show');
        
        // Special initialization for certain modals
        if (modalId === 'quantum-lab') {
            setTimeout(updateQuantumLab, 500);
        } else if (modalId === 'holo-photos') {
            updateHoloGallery();
        }
    }
}

function hideModal(modalId) {
    playSound('close');
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.classList.remove('show');
    }
}

function openTerminal() {
    showModal('terminal');
    if (!isTerminalOpen) {
        isTerminalOpen = true;
        initTerminal();
    }
}

function initTerminal() {
    const terminal = document.getElementById('terminal-output');
    terminalOutput = [
        'SPARTAN NEURAL INTERFACE v3.7.2',
        'Cortana AI Assistant: ONLINE',
        'Neural implant status: ACTIVE',
        'Suit diagnostics: ALL SYSTEMS NOMINAL',
        '',
        'Welcome, Spartan. How can I assist you today?',
        '',
        'Type "help" for available commands.'
    ];
    
    terminalOutput.forEach((line, index) => {
        setTimeout(() => {
            const p = document.createElement('p');
            p.textContent = line;
            if (line.includes('SPARTAN') || line.includes('Cortana')) {
                p.style.color = '#00ff00';
                p.style.fontWeight = 'bold';
            }
            terminal.appendChild(p);
            terminal.scrollTop = terminal.scrollHeight;
        }, index * 100);
    });
}

function handleTerminalInput(event) {
    if (event.key === 'Enter') {
        const input = event.target;
        const command = input.value.trim().toLowerCase();
        const terminal = document.getElementById('terminal-output');
        
        // Show command
        const cmdLine = document.createElement('p');
        cmdLine.innerHTML = `<span style="color: #00ff00;">spartan@cortana:~$</span> ${input.value}`;
        terminal.appendChild(cmdLine);
        
        // Process command
        processCommand(command, terminal);
        
        input.value = '';
        terminal.scrollTop = terminal.scrollHeight;
    }
}

function processCommand(command, terminal) {
    let response = '';
    
    switch(command) {
        case 'help':
            response = `Available commands:
- status: Check suit systems
- scan: Environmental scan
- weapons: Weapon systems
- mission: Current mission status
- cortana: Talk to Cortana
- clear: Clear terminal
- time: Show current time
- matrix: Access matrix console
- hack: Initiate hack sequence`;
            break;
        case 'status':
            response = `MJOLNIR POWERED ASSAULT ARMOR
- Power: 100%
- Shields: 100%
- Health: 100%
- Motion tracker: ACTIVE
- HUD: OPERATIONAL`;
            break;
        case 'scan':
            response = `Environmental Scan Complete:
- Hostiles: 0 detected
- Friendlies: 2 detected
- Temperature: 23Â°C
- Atmosphere: Safe
- Radiation: Minimal`;
            break;
        case 'weapons':
            response = `Weapon Systems:
- MA40 Assault Rifle: READY
- M6G Magnum: READY
- Plasma Grenades: x4
- Energy Sword: CHARGED`;
            break;
        case 'cortana':
            const cortanaResponses = [
                "I'm always here when you need me, Chief.",
                "All systems are running at optimal efficiency.",
                "Would you like me to run a diagnostic?",
                "The Covenant won't know what hit them.",
                "Ready for action, Spartan."
            ];
            response = `Cortana: "${cortanaResponses[Math.floor(Math.random() * cortanaResponses.length)]}"`;
            break;
        case 'matrix':
            response = `Accessing Matrix Console...`;
            setTimeout(() => {
                toggleMatrixConsole();
            }, 1000);
            break;
        case 'hack':
            response = `Initiating hack sequence...
[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%
HACK COMPLETE - ACCESS GRANTED`;
            break;
        case 'clear':
            terminal.innerHTML = '';
            return;
        case 'time':
            response = `Current Mission Time: ${new Date().toLocaleString()}`;
            break;
        default:
            response = `Command not recognized: ${command}
Type "help" for available commands.`;
    }
    
    // Add response
    setTimeout(() => {
        const responseLine = document.createElement('p');
        responseLine.textContent = response;
        responseLine.style.color = '#ffffff';
        responseLine.style.whiteSpace = 'pre-line';
        terminal.appendChild(responseLine);
        terminal.scrollTop = terminal.scrollHeight;
    }, 100);
}

// Dynamic system stats update
function updateSystemStats() {
    Object.keys(systemStats).forEach(key => {
        systemStats[key] += (Math.random() - 0.5) * 10;
        systemStats[key] = Math.max(0, Math.min(100, systemStats[key]));
        
        const element = document.getElementById(key + '-value');
        if (element) {
            element.textContent = Math.round(systemStats[key]) + '%';
        }
        
        const bar = document.getElementById(key + '-bar');
        if (bar) {
            bar.style.width = systemStats[key] + '%';
        }
    });
}

// Close modal when clicking outside
window.onclick = function(event) {
    if (event.target.classList.contains('modal')) {
        event.target.classList.remove('show');
        playSound('close');
    }
}

// Initialize everything when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Add cyberpunk effects to body
    document.body.innerHTML += `
        <div class="cyberpunk-grid"></div>
        <div class="holographic-overlay"></div>
        <div class="data-streams"></div>
    `;
    
    // Initialize icon click events for modals
    const icons = document.querySelectorAll('.icon[data-window]');
    icons.forEach(icon => {
        icon.addEventListener('click', function() {
            const windowId = this.getAttribute('data-window');
            console.log('Clicking icon for window:', windowId);
            showModal(windowId);
        });
        
        // Add hover effects
        icon.addEventListener('mouseenter', function() {
            playSound('click');
        });
    });
    
    // Initialize close buttons for all modals
    const closeButtons = document.querySelectorAll('.close-btn');
    closeButtons.forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            const modal = this.closest('.window');
            if (modal) {
                hideModal(modal.id);
            }
        });
    });
    
    // Close modal when clicking outside
    const modals = document.querySelectorAll('.window');
    modals.forEach(modal => {
        modal.addEventListener('click', function(e) {
            if (e.target === this) {
                hideModal(this.id);
            }
        });
    });
    
    // Close modals with Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            const openModals = document.querySelectorAll('.window.show');
            openModals.forEach(modal => {
                hideModal(modal.id);
            });
        }
    });
    
    // Initialize matrix console toggle
    const consoleToggle = document.getElementById('consoleToggle');
    if (consoleToggle) {
        consoleToggle.addEventListener('click', toggleMatrixConsole);
    }
    
    // Initialize holo carousel
    initHoloCarousel();
    
    // Start widget updates
    updateTimeWidget();
    setInterval(updateTimeWidget, 1000);
    
    updateAIStats();
    setInterval(updateAIStats, 2000);
    
    setInterval(updateQuantumLab, 3000);
    setInterval(updateSystemStats, 2000);
    
    // Initialize holo gallery
    setTimeout(updateHoloGallery, 500);
    
    // Create dynamic particles effect
    createParticleEffect();
    
    console.log('ðŸš€ CYBERPUNK SYSTEM INITIALIZED ðŸš€');
    console.log('ðŸ”¥ MATRIX PROTOCOL ACTIVE ðŸ”¥');
    console.log('âš¡ NEURAL INTERFACE ONLINE âš¡');
});

// Particle effect system
function createParticleEffect() {
    const particles = [];
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.style.position = 'fixed';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.pointerEvents = 'none';
    canvas.style.zIndex = '5';
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    document.body.appendChild(canvas);
    
    // Create particles
    for (let i = 0; i < 50; i++) {
        particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            size: Math.random() * 2 + 1,
            opacity: Math.random() * 0.5 + 0.3
        });
    }
    
    function animateParticles() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        particles.forEach(particle => {
            particle.x += particle.vx;
            particle.y += particle.vy;
            
            // Wrap around screen
            if (particle.x < 0) particle.x = canvas.width;
            if (particle.x > canvas.width) particle.x = 0;
            if (particle.y < 0) particle.y = canvas.height;
            if (particle.y > canvas.height) particle.y = 0;
            
            // Draw particle
            ctx.fillStyle = `rgba(0, 255, 255, ${particle.opacity})`;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
        });
        
        requestAnimationFrame(animateParticles);
    }
    
    animateParticles();
    
    // Resize handler
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
}

// =============================================
// SISTEMA DE AUDIO CYBERPUNK AVANZADO
// =============================================

class CyberpunkAudioSystem {
    constructor() {
        this.sounds = {};
        this.volume = 0.5;
        this.isMuted = false;
        this.ambientPlaying = false;
        this.audioContext = null;
        this.init();
    }
    
    init() {
        // Inicializar Audio Context
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.log('Web Audio API not supported');
            return;
        }
        
        // Configurar controles
        this.setupControls();
        
        // Configurar eventos de sonido
        this.setupSoundEvents();
        
        // Crear sonidos sintÃ©ticos
        this.createSynthSounds();
    }
    
    setupControls() {
        const audioToggle = document.getElementById('audioToggle');
        const volumeSlider = document.getElementById('volumeSlider');
        
        if (audioToggle) {
            audioToggle.addEventListener('click', () => this.toggleMute());
        }
        
        if (volumeSlider) {
            volumeSlider.value = this.volume * 100;
            volumeSlider.addEventListener('input', (e) => {
                this.setVolume(e.target.value / 100);
            });
        }
    }
    
    setupSoundEvents() {
        // Activar audio context en primera interacciÃ³n
        document.addEventListener('click', () => {
            if (this.audioContext && this.audioContext.state === 'suspended') {
                this.audioContext.resume();
                this.showSoundNotification('Audio System Activated!');
            }
        }, { once: true });
        
        // Sonidos en hover de iconos
        document.querySelectorAll('.icon').forEach(icon => {
            icon.addEventListener('mouseenter', () => this.play('hover'));
            icon.addEventListener('click', () => this.play('click'));
        });
        
        // Sonidos en botones del widget AI
        document.querySelectorAll('.ai-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.play('matrixBeep');
                this.showSoundNotification('AI Command Executed');
            });
        });
        
        // Sonidos en ventanas
        document.querySelectorAll('.close-btn').forEach(btn => {
            btn.addEventListener('click', () => this.play('close'));
        });
        
        // Sonidos en terminal
        const terminalInput = document.getElementById('terminalInput');
        if (terminalInput) {
            terminalInput.addEventListener('keypress', () => this.play('terminalType'));
        }
        
                // Configurar eventos de sonido
        this.setupSoundEvents();
        
        // Sonido de power up al cargar la pÃ¡gina
        window.addEventListener('load', () => {
            setTimeout(() => this.play('powerUp'), 1000);
        });
    }
    
    createSynthSounds() {
        if (!this.audioContext) return;
        
        // Definir los sonidos sintÃ©ticos
        this.sounds = {
            click: () => this.createBeep(800, 0.1, 'square'),
            hover: () => this.createBeep(400, 0.05, 'sine'),
            open: () => this.createRiseSound(200, 600, 0.3),
            close: () => this.createFallSound(600, 200, 0.3),
            matrixBeep: () => this.createMatrixBeep(),
            terminalType: () => this.createTypeSound(),
            neuralPulse: () => this.createPulseSound(),
            powerUp: () => this.createPowerUpSound(),
            glitch: () => this.createGlitchSound()
        };
    }
    
    createBeep(frequency, duration, type = 'sine') {
        if (!this.audioContext || this.isMuted) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
        
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + duration);
    }
    
    createRiseSound(startFreq, endFreq, duration) {
        if (!this.audioContext || this.isMuted) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.setValueAtTime(startFreq, this.audioContext.currentTime);
        oscillator.frequency.linearRampToValueAtTime(endFreq, this.audioContext.currentTime + duration);
        oscillator.type = 'sawtooth';
        
        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(this.volume * 0.2, this.audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
        
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + duration);
    }
    
    createFallSound(startFreq, endFreq, duration) {
        if (!this.audioContext || this.isMuted) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.setValueAtTime(startFreq, this.audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(endFreq, this.audioContext.currentTime + duration);
        oscillator.type = 'triangle';
        
        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(this.volume * 0.2, this.audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
        
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + duration);
    }
    
    createMatrixBeep() {
        if (!this.audioContext || this.isMuted) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = 1200;
        oscillator.type = 'square';
        
        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(this.volume * 0.4, this.audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.15);
        
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + 0.15);
    }
    
    createTypeSound() {
        if (!this.audioContext || this.isMuted) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = 600 + Math.random() * 200;
        oscillator.type = 'square';
        
        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(this.volume * 0.1, this.audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.05);
        
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + 0.05);
    }
    
    createPulseSound() {
        if (!this.audioContext || this.isMuted) return;
        
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = 300 - (i * 50);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.2);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.2);
            }, i * 100);
        }
    }
    
    createPowerUpSound() {
        if (!this.audioContext || this.isMuted) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.5);
        oscillator.type = 'sawtooth';
        
        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.1);
        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.5);
        
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + 0.5);
    }
    
    createGlitchSound() {
        if (!this.audioContext || this.isMuted) return;
        
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = Math.random() * 2000 + 200;
                oscillator.type = 'square';
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(this.volume * 0.2, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.03);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.03);
            }, i * 20);
        }
    }
    
    play(soundName) {
        if (this.isMuted || !this.sounds[soundName]) return;
        
        // Reanudar audio context si estÃ¡ suspendido
        if (this.audioContext.state === 'suspended') {
            this.audioContext.resume();
        }
        
        // Ejecutar el sonido sintÃ©tico
        this.sounds[soundName]();
        
        // Crear visualizaciÃ³n de audio
        this.createAudioVisualization();
        
        // Mostrar notificaciÃ³n
        this.showSoundNotification(`Playing: ${soundName}`);
    }
    
    playAmbient() {
        // Para ambiente, usaremos un loop de sonidos suaves
        if (this.ambientPlaying || this.isMuted) return;
        
        this.ambientPlaying = true;
        this.showSoundNotification('Cyberpunk Ambient Active');
        
        const playAmbientLoop = () => {
            if (!this.ambientPlaying || this.isMuted) return;
            
            // Crear sonido ambiente suave
            if (this.audioContext && Math.random() < 0.3) {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = 50 + Math.random() * 100;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(this.volume * 0.05, this.audioContext.currentTime + 1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 3);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 3);
            }
            
            setTimeout(playAmbientLoop, 2000 + Math.random() * 3000);
        };
        
        playAmbientLoop();
    }
    
    play(soundName) {
        if (this.isMuted || !this.sounds[soundName]) return;
        
        const sound = this.sounds[soundName];
        sound.currentTime = 0;
        sound.volume = this.volume;
        sound.play().catch(e => console.log(`Audio play failed for ${soundName}:`, e));
        
        // Crear visualizaciÃ³n de audio
        this.createAudioVisualization();
    }
    
    playAmbient() {
        if (this.isMuted || !this.sounds.ambient || this.ambientPlaying) return;
        
        this.sounds.ambient.volume = this.volume * 0.3; // MÃ¡s suave para mÃºsica de fondo
        this.sounds.ambient.play().catch(e => console.log('Ambient audio play failed:', e));
        this.ambientPlaying = true;
        
        this.showSoundNotification('Cyberpunk Ambient Active');
    }
    
    stopAmbient() {
        this.ambientPlaying = false;
        this.showSoundNotification('Ambient Audio Stopped');
    }
    
    setVolume(volume) {
        this.volume = Math.max(0, Math.min(1, volume));
        
        // Actualizar slider
        const volumeSlider = document.getElementById('volumeSlider');
        if (volumeSlider) {
            volumeSlider.value = this.volume * 100;
        }
    }
    
    toggleMute() {
        this.isMuted = !this.isMuted;
        const audioToggle = document.getElementById('audioToggle');
        
        if (this.isMuted) {
            audioToggle.textContent = 'ðŸ”‡';
            audioToggle.classList.add('muted');
            this.stopAmbient();
            this.showSoundNotification('Audio Muted');
        } else {
            audioToggle.textContent = 'ðŸ”Š';
            audioToggle.classList.remove('muted');
            this.showSoundNotification('Audio Enabled');
        }
    }
    
    createAudioVisualization() {
        // Crear visualizador temporal en el control de audio
        const audioControl = document.getElementById('audioControl');
        if (!audioControl) return;
        
        let visualizer = audioControl.querySelector('.audio-visualizer');
        if (!visualizer) {
            visualizer = document.createElement('div');
            visualizer.className = 'audio-visualizer';
            for (let i = 0; i < 5; i++) {
                const bar = document.createElement('div');
                bar.className = 'audio-bar';
                visualizer.appendChild(bar);
            }
            audioControl.appendChild(visualizer);
        }
        
        // Activar animaciÃ³n temporal
        visualizer.style.opacity = '1';
        setTimeout(() => {
            if (visualizer) visualizer.style.opacity = '0.3';
        }, 1000);
    }
    
    showSoundNotification(message) {
        // Crear o actualizar notificaciÃ³n
        let notification = document.querySelector('.sound-notification');
        if (!notification) {
            notification = document.createElement('div');
            notification.className = 'sound-notification';
            document.body.appendChild(notification);
        }
        
        notification.textContent = `â™ª ${message}`;
        notification.classList.remove('hide');
        notification.classList.add('show');
        
        // Ocultar despuÃ©s de 2 segundos
        setTimeout(() => {
            notification.classList.remove('show');
            notification.classList.add('hide');
        }, 2000);
    }
    
    // Efectos especiales de sonido
    glitchEffect() {
        if (!this.isMuted) {
            this.play('glitch');
            // Crear efecto visual de glitch
            document.body.style.filter = 'hue-rotate(180deg) saturate(2)';
            setTimeout(() => {
                document.body.style.filter = '';
            }, 200);
        }
    }
    
    neuralPulse() {
        if (!this.isMuted) {
            this.play('neuralPulse');
            // Efecto visual de pulso neural
            const widgets = document.querySelectorAll('.cyber-widget');
            widgets.forEach(widget => {
                widget.style.boxShadow = '0 0 30px #00aaff';
                setTimeout(() => {
                    widget.style.boxShadow = '';
                }, 300);
            });
        }
    }
}

// Inicializar el sistema de audio
let cyberpunkAudio;
document.addEventListener('DOMContentLoaded', () => {
    cyberpunkAudio = new CyberpunkAudioSystem();
    
    // Efectos especiales programados
    setInterval(() => {
        if (Math.random() < 0.1) { // 10% de probabilidad cada 5 segundos
            cyberpunkAudio.neuralPulse();
        }
    }, 5000);
    
    // Efecto de glitch ocasional
    setInterval(() => {
        if (Math.random() < 0.05) { // 5% de probabilidad cada 10 segundos
            cyberpunkAudio.glitchEffect();
        }
    }, 10000);
});

// FunciÃ³n global para reproducir sonidos desde cualquier parte
function playCyberpunkSound(soundName) {
    if (cyberpunkAudio) {
        cyberpunkAudio.play(soundName);
    }
}
